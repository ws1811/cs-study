1. http get 전송 방식에서 데이터를 캐싱한다고 했다!
준현님의 피드백처럼 get방식이 데이터를 캐싱한다 >> 그럼 이런 문제점이 생길 수 있고, 해결법은 무엇인지 고민해보기!

   Q1) 그럼 캐싱된 결과는 언제까지 저장되는가?
   
   A1) header에 명시된 값에 따른다! (특히 cache-contorl헤더와 expires헤더가 캐시의 동작과 유효기간을 결정한다.)
   
   참고) 캐싱된 결과는 웹 브라우저나 프록시 서버 등 캐시 저장소에 저장되어 유효기간까지 유지된다.


   Q2) 동일 요청이 들어왔을 때 캐싱되어있는 조회결과가 최신 데이터라는 것을 어떻게 보장받는가?
   
   A2) 먼저 요청 header를 사용하는 방법들이 있다.
   
   **If-Modified-since**
   - 캐싱된 결과의 "마지막 수정시간"을 if modified since 헤더에 포함해 서버에 요청보낸다.
   - 서버는 요청받은 시간 이후에 데이터가 변경되었나? 를 확인 변경되었으면 새로운 데이터와 200OK응답
     변경되지 않았다면 304 not modified 응답 반환해서 캐싱된 데이터 사용하면 된다!

   **If-None-match**
   - 캐싱된 결과의 Etag값을 if_None_match헤더에 포함해 서버에 요청보낸다.
     *ETag*란?
     - 데이터의 고유한 식별자. 데이터가 변경될 때마다 갱신된다. (사람으로치면 지문, 주민번호라고 생각!)
     - 응답헤더이다.
    - 서버는 이러한 Etag값을 확인해 데이터에 변경이 있는지 판단한다.
    - 마찬가지로 변경됨? 새로운 데이터 + 200OK응답
    - 변경안됨? 304 not nodified응답
  
  출처) https://www.inflearn.com/questions/853497/get-%EC%A1%B0%ED%9A%8C-%EA%B2%B0%EA%B3%BC-%EC%BA%90%EC%8B%B1
  일단 간단하게 해결법만 언급하고, 인프런 강의로 더 들어야 할 것 같다!
  - https://velog.io/@duarufp06/HTTP-%ED%97%A4%EB%8D%94%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%902


2. 3 tiear구조
  - 3계층 구조란 말그대로 애플리케이션을 3개의 계층으로 분리!
  - 프레젠테이션 계층과 사용자 인터페이스 / 데이터가 처리되는 애플리케이션 계층 / 애플리케이션의 데이터가 저장,관리되는 데이터 계층
    ![image](https://github.com/ws1811/cs-study/assets/117894789/ebba572e-cab7-4fcb-a318-5c8b342e9ed9)

    계층 하나하나 알아보자!
    
    **1.프레젠테이션 계층(클라이언트 계층)**
    - 사용자가 직접 마주하게 되는 계층. UI(사용자 인터페이스)나 front-end라고 부른다.
    - 사용자와 직접 상호작용하는 부분. 즉 사용자가 데이터를 입력하거나 결과를 볼 수 있는 화면을 제공!
    - 주로 HTML, Javascript, CSS, 이미지 자료 ... 가 이 계층에 해당한다.
   
    **2.애플리케이션 계층(비즈니스 로직계층 or 트랜잭션 계층이라고도 한다)**
    - 비즈니스 로직을 처리한다. **WAS를 쓰면 동적인 데이터 제공을 담당!**
    - 앞의 프레젠테이션 계층에서 요청한 데이터를 응답하는 서버역할처럼 동작한다.
    - (뒤의 데이터 계층에서보면 애플리케이션 > 데이터 계층에게 데이터를 요청하니까 클라이언트처럼 동작하게된다.)
    - 이 계층을 middleware나 back-end라고 부른다.
    - PHP, Java..가 이 계층에 해당한다.
   
    **3.데이터 계층**
    - DB에 더해서 DB에 접근해서 데이터 읽거나 쓰는것, 관리 까지 포함된다.
    - DBMS(DB관리 시스템)까지 이 계층에 해당된다.
    - Mysql, MongoDB...
   
  **이러한 3 tier 구조의 장단점**
  - 장점
    - 각 계층이 분리 되어있으므로 업무 분담 가능! > 업무 효율성 증가 유지보수하기도 쉽다.
    - 로드 밸런스처럼 여러대의 서버로 각 계층의 부하를 줄일 수 있다. (이 점이 이해가 잘 안간다.. 1tier구조는 로드밸런서같은 분산기술 쓸 수 없나?) 특히 어느 특정 계층만 scale up해주기도 가능
    - 참고로 3계층은 보통 물리적으로 구분되어있어서 각 계층의 변화가 생기더라도 서로 영향안받고 독립적이다!
   
  - 단점
    - 1계층으로만 쓰는것보단 관리나 비용이 많이들고 어려울 수 있다.


출처) https://velog.io/@leesomyoung/MVC-%ED%8C%A8%ED%84%B4-vs-3-tier-architecture


3. MVC 패턴
![image](https://github.com/ws1811/cs-study/assets/117894789/c3748045-1067-472e-8247-1c9cf7e3415c)

  - model / view / contoroller 3가지 "구성요소"로 분리해 독립적으로 개발한다!
  - 사용자가 contoroller를 조작한다 > contoroller는 model을 통해 데이터를 가져오고, 그 데이터를 바탕으로 > view를 통해 시각적 표현을 제어하여 사용자에게 전달한다.

  **1.Model**
  - 데이터를 가진 객체를 모델이라고 부른다.
  - 데이터란 내부 상태에 대한 정보, 모델의 이름, 속성...
  - 모델의 상태 변화가 있으면 컨트롤러와 뷰에 이를 통보한다.

    통보해야 뷰가 최신결과를 보여줄 수 있고, 컨트롤러도 바뀐 사항에 적용 가능한 명령을 수정해야한다.
    없어진 명령은 삭제, 새로 추가된 것, 아니면 기존 기능에서 수정이 된 것..
    * 모델의 규칙
    1. 사용자가 편집하길 원하는 모든 데이터 가지고 있어야 한다.
    2. 뷰나 컨트롤러에 대해서 모델은 어떠한 정보도 알지 말아야 한다.
    3. 변경이 일어나면 통지 어떻게 할건지 처리 방법 구현해야 한다.
   
  **2.View**
  - 사용자 인터페이스다. 사용자가 볼 결과물을 생성하기 위해 모델로부터 정보를 불러온다.
    * 뷰 규칙
    1. 모델이 가지고 잇는 정보를 따로 저장해선 안된다.
    2. 모델이나 컨트롤러에 대해서 뷰는 다른 구성 요소는 몰라야 한다.
    3. 변경이 일어나면 통지 어떻게 할건지 처리 방법 구현해야 한다.
   
  **3.contoroller**
  - 사용자의 요청 사항을 파악한 후, 요청에 맞는 데이터를 model에 의뢰 후 view에 반영해서 사용자에게 알려준다.
  - 모델과 뷰를 이어주는 bridge라고 보면 된다.
  - **모델이나 뷰는 서로의 존재를 모르고있기 때문 그냥 변경사항 알려주고 수신하는 정도**
  - 그러므로 컨트롤러가 이들을 중재해야 하므로 모델과 뷰에대해 알고있어야 한다.
    * 컨트롤러 규칙
    1. 컨트롤러는 모델이나 뷰에 대해서 알고 잇어야한다.
    2. 모델이나 뷰의 변경을 모니터링 해야한다.
   
  **이러한 MVC 패턴의 장단점**
  - 장점
    - 비지니스 로직과 UI 로직을 분리 > 코드 가독성 높아져서 유지보수 독립적으로 가능(모듈화)
    - Model과 view가 다른 요소들에 종속되지 않는다. 즉 확장과 유연성에 유리하다.
    - 재사용성 > 동일한 model을 여러 view에서 사용할 수 있다.
   
  - 단점
    - contoller가 view랑 model의 상호작용을 처리하기 때문에, contoroller 너무 거대해 질 수 있다.
    - 프로그램이 커지면 다수의 view나 model이 컨트롤러에 연괼되기 때문에 컨트롤러가 불필요하게 커지는 현상
    - massive-view-contoroller라고 한다.
   
   ![image](https://github.com/ws1811/cs-study/assets/117894789/42b8f980-7fe1-4516-b7b6-e839c036e012)


   - model은 contoroller를 통해 view와 연결되는데, 하나의 view에 연결될 수 있는 model이 여러개이므로 view와 model이 의존성을 듸게 된다.
