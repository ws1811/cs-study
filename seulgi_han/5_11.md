**DNS Round Robin**
- **부하 분산의 대표적인 알고리즘**
- 어떤 웹 서비스가 있을 때, 이 웹서비스를 담당하는 여러대의 웹 서버는 각각 자신의 공인 IP를 가지고 있다.
- 즉, 사용자가 브라우저에 DNS 도메인 주소를 입력 => 라운드 로빈 방식에 의해 여러대의 서버 중 차례에 맞게 IP가 선택돼서 사용자에게 알려줌 => 결과적으로 어떤 웹사이트에 접속하는 다수의 사용자는, 실제로 복수의 웹 서버에 나눠서 접속하게 됐던것! 서버 부하 분산하기 위해

먼저 **로드밸런서**를 알아야 한다.
- load balancer란 서버의 부하를 분산 해주는 장치나 기술.
- 즉, 서버 한대에 집중돼서 부하가 되지 않도록 traffic관리! 서버가 최적의 효율을 발휘하도록
- load balance의 기본 기능에 health check(서버가 살아있는지,연결됐는지 확인 보통 port사용), 알고리즘에 따른 분산 처리..등등이 있는데
  Round Robin은 이 알고리즘에 따른 분산처리 알고리즘중 하나라고 한다!
![image](https://github.com/ws1811/cs-study/assets/117894789/bddea1ae-965e-4194-9fae-ea567c80aac3)
- 만약 least connection 방식이었으면(최소 traffic가지는 서버부터 체우는것), ㅁ4번,ㅁ5번 traffic의 연결이 끊어졌을 때, ㅁ7번째 trafiic을 빈 4번째나 5번째 server에 넣었을 것이다.
- 하지만, round robin은 서버의 순서가 정해져 있기 때문에, 트래픽이 종료되어 비었을지라도, 순서대로 1번째 서버에 들어가게 된다. (6번째 traffic을 6번 server에 넣었으므로 다음순서는 1번 server다.)
  
**먼저 Domain name system란?**
- www.~~com 처럼 사람이 읽을 수 있는 주소를 사용한다. 이를 ip주소로 변환시켜 통신시켜 준다.
마치 전화번호 부 같은 역할.
- 사이트에 접속하기 위해 사용자가 브라우저에 도메인 주소를 보냈다. => DNS에 의해 IP주소로 변환

**round robin DNB단점**
- round robin은 서버 스펙이 비슷비슷한 경우에 사용해야한다. 성능이 좋은 서버가 있다면 그 서버에 traffic많이 할당해야 하므로 적절하지 않다.
- 이럴때!! WRR (weighted round robin)을 사용해서 각 서버에 가중치를 설정하면 분산되는 traffic 비율을 설정할 수 있다고 한다!
  
1. 서버의 수만큼 공인 IP주소가 필요하다.
2. 서버에 장애가 발생했는데도 모르고 부하를 분산시킨다. (서버에 문제가있어서 저서버로 보내면 안되는데 모르고 보내버린다! 왜? round robin DNS는 health check를 하지 않기 때문)
3. DNS 결과를 캐싱해서 재사용하기 때문에 균등한 분산이 어렵다.
- 똑같은 도메인 주소를 쳤을때, 이전에 기억사용된 IP가 캐싱되어져서 캐시된 IP주소가 반환된다.
- 프록시서버나 local DNS서버처럼 중간서버가 존재할 때, 도메인 주소를 기억하고 있기 때문에 이전에 보내준 IP를 그대로 보낸다 => 이러면 전과 똑같은 서버로 보내진 것. 다른 IP주소로 분산되지 않았다!


**참고자료**
- **load balancer와 round robin dns 외의 알고리즘 least connection, hash방**
- https://www.youtube.com/watch?v=kYipnodgi2I


**HTTP&HTTPS 복습겸 다시!**
- 클라이언트와 서버가 resource를 주고 받을 때 쓰는 통신 규약.
- 앞에 http를 붙여서 읽는법을 알려줌. 여기가 위치고, 여기가 쿼리고!!.. (마치 개인정보에서 여기가 주소, 이름, 전화번호야! 알려주는 것처럼)
- text 교환이므로 누군가가 신호를 가로채서 해킹, 변조 시킬 수 있다. => https로 해결

**HTTPS**
- TLS/SSL 사용
- https로 정보 감췄다고 안전한건 아니다. 중간에 해커가 naver.com인척해서 경로 가로챌수도. (여기로 오세요~~ 가짜 네이버)
- 그러므로 key뿐만 아니라 CA인증기관으로부터 **인증서**를 받아 진짜 naver.com인것을 인증해줘서 해결한다.

**HTTPS symmetric key**
![image](https://github.com/ws1811/cs-study/assets/117894789/6b96b37c-c05a-4aa3-bbcd-011e5bff154a)
- 서버와 클라이언트가 "똑같은 (대칭)key"를 가지고 있어서 서로만 해독할 수 있도록!
- 27 30 30 27 51 보내면 어떤 메시지인지 알 수 있음.
- 문제점) 근데 양쪽이 똑같이 key를 보유하려면 한쪽에서 만든거 넘겨줘야하는데, 이때 넘겨주다가 내 해독표를 해커가 가로채면 어떡해..? => 이래서 비대칭키=공개키가 개발됨!

**비대칭키=공개키**
- 서로 다르게생긴 열쇠가 한쌍!이라서 비대칭키라고 불림
- **A키로 암호화한건 B키로만 풀 수 있고, B키로 암호화한건 A키로만 풀 수 있다!**
- 즉, 두개의 키를 가지고 있다고 했지! 하나는 나만 가지고있고(개인키) 하나는 대중에게 공개!(공개키)

**이제 https 비대칭키로 정보를 주고받는 과정을 알아보자**
![image](https://github.com/ws1811/cs-study/assets/117894789/c1b19a83-d250-411a-854f-4c3c3ec3e941)
- 사용자는 naver에서 까준 공개키로 내 ID/비번을 암호화해서 네이버 서버에 보낸다!
(중간에 누가 가로채도 걱정 노노 이걸 풀려면 naver개인키로 밖에 못푼다. naver 공개키로 암호화해서 naver 개인키로밖에 못푼다.)

- 똑같은 예제
![image](https://github.com/ws1811/cs-study/assets/117894789/f3e569ac-a50b-4cbd-861c-df8e9aaf3608)
- A의 공개키가 오픈됐다. B는 B의 비밀 메시지를 A의 공개키를 통해 암호화! => 이건이제 A의 개인키로밖에 못연다. 해커가 암호화한 B의 비밀메시지 가져가도 전혀 노프라블럼><

- 참고) 네이버 공개키도 이게 진짜 네이버 공개키인걸 인증해줘야겠지?(CA에서 인증받은 신뢰할수있는 인증서 필요!)
- 문제점) 비대칭키 방식은 컴퓨터 부하가 너무 크다.
  
**그래서 대칭키+비대칭키 섞어쓴다!**

**TLS: transfer layer security 전송 계층 보안**
- SSL 업그레이드 시킨것! 여전히 SSL이라고 부르기도함.

**SSL: secure socket layer 흐름**
<사전과정>

1. 일단 사이트는 CA인증기관과 인증서를 계약한다. 인증기관은 사이트의 공개키+정보를 인증기관만의 개인키로 암호화한다.
  - 즉, 내 사이트의 공개키를 CA기업에게 관리를 부탁하는 것.
2. 인증기관의 공개키를 브라우저에 제공한다.
- 즉, 네이버 사이트의 공개키정보를 인증기관 개인키로 암호화했지? 이건 인증기관 공개키로밖에 못풀어.

<최종정리-ssl통신과정>
- 핵심은 인증서와 암호화!

1. 사용자가 사이트로 접속 요청하면 네이버는 일단 "인증서"(CA랑계약체결해서 CA개인키로 암호화것) 준다.
2. 이 인증서가 진짜인가? 브라우저에 있는 인증기관 공개키로 까본다.
=> 인증서가 인증기관 개인키로 암호화 되어있던 **진짜**였으면 짝인 인증기관 공개키로만 풀릴것이다! 풀리면 인증완료!
3. 네이버의 공개키로 대칭키를 암호화해서 전송(위에서 대칭키는 문자해독표. 해킹당하면 큰일남)
4. 네이버 사이트는 전송받은 암호화된 대칭키를 네이버 개인키로 복호화.
- 이제 사용자, 네이버사이트 사이에 symetric key! 같은 대칭키를 가지게 됐다!
5. 이제 데이터 주고받을 때 대칭키로 암호화해서 전송하면된다! (안전하게 암호해독표를 서로 가지게됐음!)

- 즉, 서로 대칭키(암호해독표) 가지기 까지를 비대칭키 방식 써서 보내고, 서로 이제 대칭키 가지고 잇으니까 대칭키 사용해서 암호화/전달한다.


**참고자료**
- https://github.com/Songwonseok/CS-Study/blob/main/Network/HTTP%26HTTPS.md
- https://www.youtube.com/watch?v=H6lpFRpyl14 (얄팍한 코딩사전 대칭키, https)
  https://www.youtube.com/watch?v=MR4sCU82tgo (생활코딩 대칭키, https)
