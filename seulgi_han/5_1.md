**1. GET과 POST의 차이점**
   
- 둘다 서버에 무언가를 요청할 때 쓰이는 방식이다!
- GET은 헤더, POST는 바디에 요청데이터를 담아서 전송한다.
- GET은 url에 요청 데이터를 붙여서 전달하기 때문에, 보안성이 낮고 보낼수 있는 데이터크기에 제한이 크다.
- GET은 select처럼 데이터를 가져오는 용도. POST는 서버의 값이나 상태를 변경한다.(데이터 수정 삭제 삽입)
- POST 방식 ex) 회원가입, 게시글 작성, 게시글 삭제, 파일 업로드..

주의점) POST타입으로 써야하는데 보안이 별로 안중요하고 데이터 크기가 작으면 GET방식 쓰면 되겠네?
=> X 목적에 맞게 사용해야한다. 
- GET방식은 브라우저에서 **캐싱**한다. 즉, 캐싱덕에 속도는 빠를 수 있지만, 기존에 캐싱되었던 데이터가 잘못 응답될수도 있기 때문
- 피드백) 검증헤더 / 바디 (화면위주) 헤더랑 바디, html5 문법먼저 공부해야할듯하다.

**GET방식**
- url뒤에 ?이후에 붙여서 요청데이터를 표현한다.
- key value쌍으로 넣어야하며 &로 구분
- http패킷에서 헤더에 포함된다.
  (즉, body부분은 거의 비게되며, body부분이 없으므로 body의 데이터를 설명하는 content-type의 헤더필드는 들어가지 않는다.)
- 장점) url뒤에 붙이기 때문에 사람마다 접속이 쉽다.
- 단점) url에 붙여서 보내는 만큼 데이터 보내는 양에 제한적이고, 다드러나서 보안에 취약하다.
- 데이터가 그대로 url에 노출 => 비밀번호 같은거 get방식 쓰면 절대안된다. => 피드백) 잘못된 지식! 써도됨 가려서 보낼수있음 보안이 낮을뿐

**POST방식**
- 서버에 저장된 리소스를 생성/변경하기 위해 사용된다. (게시글 작성, 삭제, 회원가입, 파일 업로드)
- 요청 데이터가 body부분에 담겨서 전송된다.
- => 때문에 body의 데이터를 설명해주는 content-type이라는 헤더필드가 필요하다.
  
*이러한 content type에는*
1. key value로 쓰고 &로 구분(default)
2. txt로만 표현
3. 바이너리 데이터로 표현
이렇게 데이터가 어떤 방식으로 쓰여졌는지 설명해준다고 한다.

**3way-handshake**
- tcp/ip통산에도 사용되는 방식이다.
- syn, ack패킷을 주고받으며 클라이언트와 서버의 connection(연결)을 확인한다.
1. 클라이언트가 서버에게 syn패킷을 보냄(잘들리니?)
2. 서버가 클라이언트에게 ack패킷과(잘들려!) syn패킷(너도 잘들리니?) 전달
3. 클라이언트가 서버에게 ack패킷 전달(나도 잘들려!)

- 연결 해제때는 4way-handshake
- syn대신 fin플래그 라는 것 + ack패킷을 전송하며 연결을 종료한다고한다.
- 아직 도착 못한 데이터가 있을까 세션을 남겨놓고 잉여패킷을 기다리는 time wait을 하기도 한다!

**TCP/UDP프로토콜**
- 둘다 전송 계층에서 데이터를 보내기 위해 사용되는 프로토콜이다.
- (전송계층이란 송신자와 수신자를 연결하는 통신서비스를 제공하는 계층 즉, 그냥 데이터의 전달을 담당한다.)
  
**UDP**
- IP랑 거의비슷하다. IP에 port랑 체크섬 정도만 추가한것!
- 연결을 위해 할당되는 논리적인 경로가 없다는 뜻이다.
  즉, 각각의 패킷은 다른 경로로 전송, 독립적인 관계를 지닌다.
  ![image](https://github.com/ws1811/cs-study/assets/117894789/b06333ac-5702-49f1-80ca-9b83a182e0a7)
  
- 순서부여하고 순서잘못가면 재조립하고 그런거 없다. 신뢰성과 연결성이 없는 대신, 단순하고 빠르다. 
- 대신 체크섬정도로 전송된 데이터 최소한의 오류검사는 한다.
  
**TCP**
- 패킷을 전송하기 위한 논리적 경로를 배정한다.
![image](https://github.com/ws1811/cs-study/assets/117894789/a162f74e-405e-4cfc-b674-6daca03718d3)

- **신뢰성**과 **연결성**이있다! 데이터의 흐름이나 혼잡같은 **전송제어**도 가능하다고함!
- (흐름제어 flow control 송수신 하는 곳에 데이터 처리속도 조절. 감당안되게 데이터 빨리보내서 오버플로우 터지는것 막음)
- (혼잡제어 congestion control 너무 많은 데이터가 오면 안된다. 패킷 수가 넘치지 않도록 방지.)
- **3way handshake** 때문에 서버와 클라이언트 연결 확인이 되며, 데이터를 잘 전달받았는지 확인도 하고(택배 받았으면 연락주세요~),
- **순서도 보장**된다! (1,2,3순선데 1,3,2로 전달됐어. 2부터 다시보내줘)
- 전이중(full-duplex), 점대점(point to point)방식이다.
- (전이중이란 전송이 양방향으로 동시에 일어날 수 있음을 의미 무전기가아니고 전화다!)
- (점대점이란 서버와 클라이언트는 1:1로 연결된다.)

**Http/Https**
- http는 tcp/ip 전송 프로토콜을 이용하는데, 보내는 도중 누군가 데이터를 엿보거나 변조시킬 수 있고,
- 서버와 클라이언트중 위장해서 데이터를 가로채갈 수도 있다. 즉 보안에 취약
- SSL secure socket layer라는 프로토콜을 조합해서 http내용을 암호화한게 https다.
- SSL은 상대를 확인하는 증명서다. 증명서로 상대방을 확인하고, 암호화해서 중간에 데이터 열어보거나 변조를 막는다.



**추가 궁금한 것 공부**

**IP**
- 인터넷 프로토콜로 택배보낼 주소다.(데이터를 전송할 주소)
- 패킷이라는 통신단위로 데이터를 전달한다.
  
**IP단점**
- 비연결성. 패킷을 받을 대상이 없거나 서비스 불능상태인지 확인도 안하고 그냥 일단 전송한다.
- 비신뢰성. 중간에 데이터 패킷이 사라지거나 순서가 꼬이면? **UDP단점이랑 똑같다.**
- IP 만으로는 같은 서버에서 애플리케이션들 구분이 안된다. 아파트까진 왔는데 몇호지..?
- **IP는 PORT조차 없다.**

**DNS**
- ip주소는 넘 복잡해서 사람이 외우기 힘들어. (url같은) domain name으로 바꿔.

**proxy server**
- 중간 서버, 캐시를 보관하거나, 중간에 껴서 서버와 직접 소통하지 못하도록해 서버의 IP주소를 숨겨준다.
- 클라이언트 - proxy - 서버 (중간 연결자 역할)

**port**
- 같은 IP내에서 프로세스들을 구분해준다. 내가 게임을 하고있는지, 웹검색을 하고있는지, 메일을 보내고있는지..
- 즉 IP로 컴퓨터를 찾아가서, 더해서 클라이언트가 접속할 정확한 프로그의 위치를 알려준다.

**패킷Packet**
- 인터넷 내에서 데이터를 보내기위 경로배정을 효율적으로 하기 위해 데이터를 여러개의 조각들로 나눠서 전송한다.
- 이 조각을 패킷이라고 한다.

